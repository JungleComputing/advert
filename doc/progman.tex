\documentclass[10pt]{article}

\usepackage{url}
\usepackage{fancyvrb}

\DefineVerbatimEnvironment
  {code}{Verbatim}
  {fontsize=\small, frame=single, numbers=left}

\begin{document}

\title{Google App Engine Advert Server Programmer's Manual}

\author{
  Bas Boterman (\texttt{bboterm@cs.vu.nl})\\
  \small Dept. Computer Science, Vrije Universiteit, Amsterdam, The Netherlands
}

\maketitle

\section{Introduction}
\label{introduction}
This manual explains how to program applications using the Advert server running
on the Google App Engine. For information on how to install the server, please
see the \texttt{INSTALL.txt}, located in the \texttt{server} directory.

In this manual, we will focus mainly on the protocol used between the Advert
Library and the Advert server, as run on the Google App Engine. Also, we mostly
refer to Java as the language of the client-side. This manual is split up into
several different sections. First, we will explain how connections are made
between a client and the Advert server (Section \ref{http-java}). Second, we will
discuss how authentication is done, between a client and the Google App Engine
(Section \ref{auth}). Third we will discuss the various different functions
provided by the Advert server, and how they are addressed (Section
\ref{protocol}). Fourth we will take a look at the administration panel of the
Google App Engine (Section \ref{admin-panel}). Last we will take a look at an
example of a client implementation, by looking at the \emph{Ibis Advert library}
(Section \ref{advert-lib}).

\section{Connecting to the Google App Engine}
\label{http-java}
This section will give a general idea of how connections are established
between a Java client and the Google App Engine. As of yet, the Google App
Engine only supports HTTP(S) connections over port 80. This means that all our
requests and responses must be encoded to fit in an HTTP request/response. We
will come to encoding data into HTTP requests in Section \ref{protocol}, when
we discuss our protocol.

Connecting to the Google App Engine is fairly simple, making use of the
\texttt{java.net} package. Useful classes are the \texttt{URL} and the
\texttt{HttpURLConnection} classes, which are the most-used classes for making
HTTP connections through Java. For more information on how to connect to an
HTTP server using Java, see
\url{http://java.sun.com/docs/books/tutorial/networking/urls/index.html}.

Note that sometimes it is required to make HTTPS connections over SSL
(e.g. authentication). Before making an HTTPS connection, some system
properties might need to be set up. This can be done by using code shown in
Figure \ref{ssl-setup}.

\begin{figure*}[ht] %[placement] where placement is h,t,b,p
\begin{center}
\begin{code}
System.setProperty("java.protocol.handler.pkgs",
                        "com.sun.net.ssl.internal.www.protocol");
Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
\end{code}
\caption{Setting up SSL.\label{ssl-setup}}
\end{center}
\end{figure*}

\section{Authenticating to the Google App Engine}
\label{auth}
This section describes how authentication to the Google App Engine is done. If
you are using a public sever, no authentication is needed and you can proceed
reading Section \ref{protocol}.

Authenticating with the Google App Engine is done through Google's
\emph{ClientLogin}
(\url{http://code.google.com/apis/accounts/docs/AuthForInstalledApps.html}).
This is an API to programmatically log into a user's Google account. After
collecting login information from the user, call ClientLogin to request access to
the user's account. Once the login information has been successfully
authenticated, Google returns a token, which your application will reference each
time it requests access to the user's account, such as to get or post data. The
token remains valid for a set length of time, defined by whichever Google service
you're working with. To authenticate with the Google App Engine in specific,
please follow the steps as described below.

First step is to perform an HTTP POST request to the Google ClientLogin page at
\texttt{https://www.google.com/accounts/ClientLogin}. In this request we POST
some parameters which are necessary for authentication (see Figure
\ref{clientlogin-req}). The first two fields are self-explanatory. The third
field refers to the App Engine. The final field is the source application
requesting authentication. 

\begin{figure*}[ht] %[placement] where placement is h,t,b,p
\begin{center}
\begin{code}
Email=jondoe@gmail.com
Passwd=north23AZ
service=ah
source=IBIS Advert
\end{code}
\caption{Authentication Data for ClientLogin.\label{clientlogin-req}}
\end{center}
\end{figure*}

After the request is made, Google issues an HTTP response. This can either be
an \texttt{HTTP/1.0 403 Access Forbidden} response, which means the wrong
credentials were provided. In addition, a CAPTCHA\footnote{A CAPTCHA or Captcha
is a type of challenge-response test used in computing to ensure that the
response is not generated by a computer.} challenge could be initiated. If so,
we recommend to wait a sufficient amount of time, before retrying.

On the other hand, when the authentication was succesful, Google should respond
with an \texttt{HTTP/1.0 200 OK} response. After which three tokens are passed
in the message body (see Figure \ref{clientlogin-resp}). Currently, only the
\texttt{Auth=DQAAAGgA...dk3fA5N} field is used, and is needed for the other
half of the authentication process.

\begin{figure*}[ht] %[placement] where placement is h,t,b,p
\begin{center}
\begin{code}
HTTP/1.0 200 OK
Server: GFE/1.3
Content-Type: text/plain 

SID=DQAAAGgA...7Zg8CTN
LSID=DQAAAGsA...lk8BBbG
Auth=DQAAAGgA...dk3fA5N
\end{code}
\caption{ClientLogin Response.\label{clientlogin-resp}}
\end{center}
\end{figure*}

The second part of the authentication request is initiating an HTTP GET request
to the following URL:

\begin{center}
\begin{code}
http://jondoe.appspot.com/_ah/login?continue=
    https://jondoe.appspot.com/&auth=DQAAAGgA...dk3fA5N
\end{code}
\end{center}

Here, \texttt{jondoe.appspot.com} is the domain where the Advert server is
running. Note that we append the authentication token we just received from the
ClientLogin to this URL. Once this URL is requested, the App Engine will
respond with an \texttt{HTTP/1.0 302 Found} response code, trying to redirect
to the URL stated in the \texttt{continue=} part of the URL described above.
We, on the other hand, are only interested in the \emph{authentication cookie}
of the response. Once we found the header field containing the
\texttt{Set-Cookie} key, we know we have found our authentication cookie (see
Figure \ref{auth-cookie}) and we will store it in a variable so it can be used
in subsequent requests. For more information about using cookies in Java,
please see
\url{http://java.sun.com/j2se/1.5.0/docs/guide/deployment/deployment-guide/cookie\_support.html}.

\begin{figure*}[ht] %[placement] where placement is h,t,b,p
\begin{center}
\begin{code}
ACSID=AJKiYcH9...29E6Qylx; expires=Sun, 17-May-2009 12:58:04 GMT; 
    path=/; secure
\end{code}
\caption{Authentication Cookie.\label{auth-cookie}}
\end{center}
\end{figure*}

\section{The Advert Service Protocol}
\label{protocol}
Once authenticated to the Google App Engine, the client can make use of the
various functions provided by the Advert server. Currently, five functions are
implemented, being \texttt{add}, \texttt{del}, \texttt{get}, \texttt{getmd}, 
and \texttt{find}. All functions are addressed by requesting the following URL:

\begin{center}
\begin{code}
http://jondoe.appspot.com/function_name
\end{code}
\end{center}

Where \texttt{function\_name} should be replaced by the function name as
described above. Note, when using a authenticated server, for each function
authentication will be required. Not only by using a Google Account, but
the user is also required to be an administrator of this App Engine project. This
is described in more detail in Section \ref{admin-panel}. 

Since all function calls are HTTP requests, the function parameters are encoded
in the HTTP (POST) request. Encoding the parameters is done by using the
\emph{JSON} (JavaScript Object Notation) data-interchange format. At the
client-side we used \texttt{json-lib} and at the server-side we used
\texttt{simplejson} for enconding/decoding data to/from JSON. More information
on JSON and various JSON libraries can be found at \url{http://www.json.org/}.

Next, we will describe each function in more detail.

\subsection{Add}
\label{add}
The \texttt{add} function is used for adding an \emph{Advert object} to the
Advert server (i.e. the database). This function takes three parameters: 

\begin{itemize}
  \item \texttt{pathname}: the location where the object should be stored
  \item \texttt{metadata}: additional \emph{meta data} of the object
  \item \texttt{object}: the object itself
\end{itemize} 

These three parameters should be encoded in a JSON Array in this order. The
\texttt{pathname} should be a String (which is not \texttt{null}, the
\texttt{metadata} should be a JSON Object with key-value pairs (which are both
Strings) or \texttt{null}, and the \texttt{object} should be a Text (i.e. a long
string, which is a subclass of the built-in unicode type) or \texttt{null}.

Once the JSON Array is received, the server will check if the \texttt{pathname}
already exists, and if so, it will be overwritten. If \texttt{pathname} does
not exist, a new entry will be created, and the object with meta data attached
will be stored in an atomic action.

All functions can return both \texttt{403 Forbidden} and \texttt{500 Internal
Server Error} HTTP response codes. The function-specific return values of
\texttt{add} are:

\begin{itemize}
  \item \texttt{201 Created}: the data is stored successfully, and a TTL (Time to
  Live) is returned
  \item \texttt{205 Reset Content}: the data is stored successfully, but
  overwritten (also a TTL is returned)
  \item \texttt{400 Bad Request}: the JSON Array/Object is not properly
  structured, the object is not stored
  \item \texttt{503 Service Unavailable}: the transaction failed, the object is
  not stored
\end{itemize}

\subsection{Del}
\label{del}
The \texttt{del} function is used for deleting an object from the Advert
server. This function does not use JSON for parameter encoding since it only
has one parameter:

\begin{itemize}
  \item \texttt{pathname}: the location of the object to be deleted
\end{itemize}

The \texttt{pathname} should be a String which is not \texttt{null}. Once the
\texttt{pathname} is retrieved from the message body, the server will try to
atomically remove the object and all meta data associated to that path name.
Function-specific return values are:

\begin{itemize}
  \item \texttt{200 OK}: the data was removed successfully from the Advert
  server
  \item \texttt{404 Not Found}: the data associated with \texttt{pathname}
  could not be found
  \item \texttt{503 Service Unavailable}: the transaction failed, nothing is
  removed from the database
\end{itemize}

\subsection{Get}
\label{get}
The \texttt{get} function is used for retrieving data from the Advert server.
This function does not use JSON for parameter encoding since it only has one
parameter:

\begin{itemize}
  \item \texttt{pathname}: the location of the object to be fetched
\end{itemize}

The \texttt{pathname} should be a String which is not \texttt{null}. Once the
\texttt{pathname} is retrieved from the message body, the server will try to
fetch the associated object from the database. Function-specific return values
are:

\begin{itemize}
  \item \texttt{200 OK}: the data was fetched, the actual object will be sent
  as unicode text in the message body
  \item \texttt{404 Not Found}: the data associated with \texttt{pathname}
  could not be found
\end{itemize}

\subsection{GetMD}
\label{getmd}
The \texttt{getmd} function is used for retrieving meta data from the Advert
server. This function does not use JSON for parameter encoding since it only has one
parameter:

\begin{itemize}
  \item \texttt{pathname}: the location of the meta data to be fetched
\end{itemize}

The \texttt{pathname} should be a String which is not \texttt{null}. Once the
\texttt{pathname} is retrieved from the message body, the server will try to
fetch the associated meta data from the database. This meta data will be
encoded as a JSON Object (in random order). Function-specific return values are:

\begin{itemize}
  \item \texttt{200 OK}: the meta data was fetched, the actual JSON object will
  be returned in serialized form
  \item \texttt{404 Not Found}: the meta data associated with \texttt{pathname}
  could not be found, \texttt{null} is returned
\end{itemize}

\section{The Administration Panel}
\label{admin-panel}

\section{Example: The Ibis Advert Library}
\label{advert-lib}

\section{Further Reading}
\label{further}
The Javadoc included in the \texttt{javadoc} directory has detailed
information on all classes and their methods.

The Ibis web page lists all
the documentation and software available for Ibis, including papers, and
slides of presentations.

For detailed information on running an Ibis application see the
User's Manual, available in the docs directory of the Ibis
distribution.

\end{document}
